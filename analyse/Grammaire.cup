package plic.analyse ;

import java.util.*;
import plic.arbre.* ;
import plic.arbre.expression.* ;
import plic.tds.*;
import plic.tds.entrees.*;
import plic.tds.symboles.*;
import plic.exceptions.AnalyseSyntaxiqueException;

import java_cup.runtime.*;

action code {: 
             :} ;

parser code {:

    public void report_error(String message, Object info) {

        HashMap<Integer, String> lesTerminaux = new HashMap<>() ;
    
        lesTerminaux.put(new Integer(CodesLexicaux.PLUS), "+") ;
        lesTerminaux.put(new Integer(CodesLexicaux.MOINS), "-") ;
        lesTerminaux.put(new Integer(CodesLexicaux.MULT), "*") ;
        lesTerminaux.put(new Integer(CodesLexicaux.DIV), "/") ;
        lesTerminaux.put(new Integer(CodesLexicaux.PAROUV), "(") ;
        lesTerminaux.put(new Integer(CodesLexicaux.PARFER), ")") ;
        lesTerminaux.put(new Integer(CodesLexicaux.SUP), ">") ;
        lesTerminaux.put(new Integer(CodesLexicaux.INF), "<") ;
        lesTerminaux.put(new Integer(CodesLexicaux.EGALEGAL), "==") ;
        lesTerminaux.put(new Integer(CodesLexicaux.DIFF), "!=") ;
        lesTerminaux.put(new Integer(CodesLexicaux.ET), "et") ;
        lesTerminaux.put(new Integer(CodesLexicaux.OU), "ou") ;
        lesTerminaux.put(new Integer(CodesLexicaux.NON), "non") ;

        StringBuffer m = new StringBuffer() ;

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {                
                m.append("\tligne : " + (s.left + 1)) ;
                if (s.right >= 0)                    
                    m.append(" colonne : " + (s.right+1)) ;
            }
            
            if (s.value != null) {
                lesTerminaux.put(CodesLexicaux.CSTEINT, "" + s.value) ;
                lesTerminaux.put(CodesLexicaux.CSTEBOOL, "" + s.value) ;
            }

            if (lesTerminaux.containsKey(new Integer(s.sym))) {
                m.append(" dernier token lu : " + lesTerminaux.get(new Integer(s.sym))) ;
            }
            else {
                m.append(" expression non termin√©e") ;
            }

        }
        throw new AnalyseSyntaxiqueException("" + m) ;
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }
:};
   
/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals (tokens returned by the scanner).  */

terminal Symbol    PLUS, MOINS, MULT, DIV, PAROUV, PARFER, CROOUV, CROFER, EGAL,POINTVIRGULE, VIRGULE ;
terminal Symbol    SUP, INF, EGALEGAL, DIFF, ET, OU, NON;
terminal String    IDF,CSTEINT, CSTEBOOL, CSTECHAINE;
terminal String    CLASS, FIN, ENTIER, DEBUT, NOUVEAU, POUR, TANTQUE, REPETER, FINTANTQUE, SI, ALORS, SINON, FSI, LIR, ECRIR;
terminal String    PUBLIQUE, PRIVEE;
  
   
/* Non terminals used in the grammar section.  */

non terminal Expression EXPR, CSTE ;

non terminal ArbreAbstrait SYSTEME, LCLASSE, CLASSE, LDECLARATION, DECLARATION, DECL_CHAMP, DECL_CONST , DECL_FONCTION;
non terminal ArbreAbstrait LDECL_VAR, DECL_VAR,LINSTRUCTION, INSTRUCTION, AFFECT, INSTANCIATION, BOUCLE, CONDITION, LIRE, ECRIRE;
non terminal ArrayList<String> LIDF;
non terminal String TYPE, TYPE_RES, STATUT; 
non terminal Acces ACCES;

precedence left INF, SUP ;
precedence left EGALEGAL, DIFF;
precedence left PLUS, MOINS;
precedence left MULT, DIV ;
precedence left OU ;
precedence left ET ;
precedence left NON ;

/* ----------------------------Grammar Section-------------------- */
 
start with SYSTEME ;

SYSTEME		::=	LCLASSE:lc
			{: 
			   RESULT = lc; 
			:}
			;

LCLASSE		::=	LCLASSE:lc CLASSE:c
			{:
		   	   ((BlocDInstructions)lc).ajouter(c);
		  	   RESULT = lc;
			:}
		|	
			CLASSE:c
			{: 
			   ArbreAbstrait lc = new BlocDInstructions();
		   	   ((BlocDInstructions)lc).ajouter(c);
		           RESULT = lc;
			:}
			;

CLASSE		::=	CLASS IDF FIN
			{:
		   	   //la classe est vide (optimisation en ne faisant qu'une entree/sortie de bloc ?)
			:}
		|	
			CLASS IDF LDECLARATION:ld FIN
			{:
		   	   RESULT = ld;
			:}
			;

LDECLARATION	::=	LDECLARATION:ld DECLARATION:d
			{:
		   	   ((BlocDInstructions)ld).ajouter(d);
		  	   RESULT = ld;
			:}
		|	
			DECLARATION:d
			{: 
			   ArbreAbstrait ld = new BlocDInstructions();
		   	   ((BlocDInstructions)ld).ajouter(d);
		       RESULT = ld;
			:}
			;

DECLARATION 	::=	DECL_CHAMP:dc
			{:
		  	   RESULT = dc;
			:}
		|	
			DECL_CONST:dc
			{:
		  	   RESULT = dc;
			:}
		|
			DECL_FONCTION:df
			{:
		  	   RESULT = df;
			:}
			;

LIDF ::= IDF:i
		{:
		   ArrayList<String> lidf = new ArrayList<String>();
		   lidf.add(i);
		   RESULT = lidf; 
		:}
		|
		LIDF:lidf VIRGULE IDF:i
		{: 
		   lidf.add(i);
		   RESULT = lidf; 
		:}
;

DECL_CHAMP ::= STATUT:s TYPE:t LIDF:n POINTVIRGULE
				{: 
				BlocDInstructions l = new BlocDInstructions();
				for(String nidf : n) {
					l.ajouter(new Declaration(nidf,t,s));
				}
				RESULT = l; :}
;

TYPE		::=	ENTIER:e
			{:
			   RESULT = e;
			:}
		|	
			ENTIER:e CROOUV CROFER
			{:
			   RESULT = e;
			:}
		|
			IDF:i
			{:
			   RESULT = i;
			:}
			;

DECL_CONST	::=	STATUT:s IDF:i DEBUT LINSTRUCTION:li FIN
			{:  
			   // a implementer
			:}
		|
			STATUT:s IDF:i DEBUT LDECL_VAR:lv LINSTRUCTION:li FIN
			{:  
			   // a implementer
			:}
			;

LINSTRUCTION	::=	LINSTRUCTION:li INSTRUCTION:i
			{:
		   	   ((BlocDInstructions)li).ajouter(i);
		  	   RESULT = li;
			:}
		|	
			INSTRUCTION:i
			{:
			   ArbreAbstrait li = new BlocDInstructions();
		   	   ((BlocDInstructions)li).ajouter(i);
		   	   RESULT = li;
			:}
			;

LDECL_VAR	::=	LDECL_VAR:lv DECL_VAR:v
			{:
		   	   ((BlocDInstructions)lv).ajouter(v);
		  	   RESULT = lv;
			:}
		|	
			DECL_VAR:v
			{: 
			   ArbreAbstrait lv = new BlocDInstructions();
		   	   ((BlocDInstructions)lv).ajouter(v);
		           RESULT = lv;
			:}
			;

DECL_VAR	::=	TYPE IDF POINTVIRGULE
			{:
			   //plic3 fct
			:}
		|	
			TYPE IDF LIDF POINTVIRGULE
			{:
			   //plic3 fct
			:}
			;

DECL_FONCTION	::=	STATUT:s TYPE_RES IDF:i DEBUT LINSTRUCTION:li FIN
			{:  
			   // a implementer
			:}
		|
			STATUT:s TYPE_RES IDF:i DEBUT LDECL_VAR:lv LINSTRUCTION:li FIN
			{:  
			   // a implementer
			:}
			;

TYPE_RES	::=	ENTIER:e
			{:  
			   RESULT = e;
			:}
		|
			IDF:i
			{:  
			   RESULT = i;
			:}
			;

STATUT		::=	PUBLIQUE:p
			{:
			   RESULT = p;
			:}
		|	PRIVEE:p
			{:
			   RESULT = p;
			:}
			;

INSTRUCTION	::=	AFFECT:a
			{:
			   RESULT = a; 
			:}
		|
			INSTANCIATION:i
			{:
			   RESULT = i; 
			:}
		|	
			BOUCLE :b
			{:
			   RESULT = b;
			:}
		|	
			CONDITION:c
			{:
			   RESULT = c;
			:}
		|	
			LIRE:l
			{:
			   RESULT = l;
			:}
		|	
			ECRIRE:e
			{:
			   RESULT = e;
			:}
			;

AFFECT		::=	ACCES:a EGAL EXPR:e POINTVIRGULE
			{:
			   RESULT = new Affectation(e, a);
			:}
			;

INSTANCIATION	::=	ACCES EGAL NOUVEAU IDF PAROUV PARFER
			{:
			   // a implementer
			:}
			;

ACCES		::=	IDF:i
			{:
			   RESULT = new Acces(i);;
			:}
			;

BOUCLE		::=	POUR PAROUV IDF:i EGAL EXPR:e POINTVIRGULE EXPR:e2 POINTVIRGULE INSTRUCTION:i PARFER DEBUT LINSTRUCTION:li FIN
			{:
			   BlocDInstructions bloc = new BlocDinstructions();
			   bloc.add(new Affectation(e,i);
			   li.add(i);
			   bloc.add(new Boucle(e2,li);
			   
			:}
		|	
			TANTQUE EXPR:e REPETER LINSTRUCTION:l FINTANTQUE
			{:
			   RESULT = new Boucle(e,l);
			:}
			;

CONDITION	::=	SI EXPR ALORS FSI
			{:
	
			:}
		|	
			SI EXPR:e ALORS LINSTRUCTION:l FSI
			{:
			   Condition c = new Condition(e, (BlocDInstructions)l, null);
			   RESULT = c;
			:}
		|  	
			SI EXPR:e ALORS SINON LINSTRUCTION:li1 FSI
			{:
			   Condition c = new Condition(e, null,(BlocDInstructions)li1);
			   RESULT = c;
			:}
		|  	
			SI EXPR:e ALORS LINSTRUCTION:li1 SINON LINSTRUCTION:li2 FSI
			{:
			   Condition c = new Condition(e, (BlocDInstructions)li1, (BlocDInstructions)li2);
			   RESULT = c;
			:}
			;

LIRE		::=	LIR IDF
			{:
			   //a implemanter
			:}
			;

ECRIRE		::=	ECRIR EXPR:e POINTVIRGULE
			{:
			   RESULT = new EcrireExpression(e);
			:}
		|	ECRIR CSTECHAINE:c POINTVIRGULE
			{: 
			   RESULT = new EcrireChaine(c);
			:}
			;

    
EXPR    ::=     EXPR:g  PLUS  EXPR:d
                {: RESULT = new Plus(g, d) ; :}
        | 
                EXPR:g  MOINS  EXPR:d
                {: RESULT = new Moins(g, d); :}
        |                
                EXPR:g  MULT  EXPR:d
                {: RESULT = new Mult(g, d); :}
        |                
                EXPR:g  DIV  EXPR:d
                {: RESULT = new Div(g, d); :}
        |       
                EXPR:g  INF  EXPR:d
                {: RESULT = new Inferieur(g, d); :}
        |       
                EXPR:g  SUP  EXPR:d
                {: RESULT = new Superieur(g, d); :}
        |              
                EXPR:g  EGALEGAL  EXPR:d
                {: RESULT = new Egal(g, d); :}
        |       
                EXPR:g  DIFF  EXPR:d
                {: RESULT = new Different(g, d); :}
        |                      
                MOINS  EXPR:e  
                {: RESULT = new MoinsUnaire(e); :}
        |      
                EXPR:g  ET  EXPR:d
                {: RESULT = new EtLogique(g, d); :}
        |      
                EXPR:g  OU  EXPR:d
                {: RESULT = new OuLogique(g, d); :}
        |      
                NON EXPR:e
                {: RESULT = new NonLogique(e); :}
        |		
        	IDF:i
        	{: RESULT = i; :}
        |
                CSTE:c
                {: RESULT = c ; :}
        |
                PAROUV  EXPR:e  PARFER
                {: RESULT = e ; :}
                ;

CSTE    ::=     CSTEINT:e 
                {: RESULT = new ConstanteEntiere(e) ; :}
        |       
		CSTEBOOL:e 
                {: RESULT = new ConstanteBool(e) ; :}
                ;



